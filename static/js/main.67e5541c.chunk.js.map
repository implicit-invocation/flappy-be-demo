{"version":3,"sources":["lib/createLoop.js","lib/createParallax.js","createParallaxes.js","createDeco.js","index.js"],"names":["createLoop","STEP","eventEmitter","EventEmitter","running","lastUpdate","Date","now","elapsed","accumulate","loop","emit","requestAnimationFrame","onTick","handler","addListener","onFixedTick","getDelta","getFps","Math","round","stop","createParallax","tex","width","height","startX","startY","speedX","texWidth","regionWidth","regionHeight","animateX","update","delta","draw","batch","offsetX","loadParallax","gl","url","a","async","loadTexture","createParallaxGroup","parallaxes","add","parallax","push","addAll","ps","p","createParallaxes","worldWidth","worldHeight","parallaxGroup","cloudHeight","skyHeight","baseHeight","houseHeight","wireHeight","bikeHeight","treeParallax","cloudParallax","skyParallax","houseParallax","wireParallax","bikeParallax","bike2Parallax","createDeco","beeTextures","HEIGHTS","WIDTHS","xs","ys","ss","ts","random","type","i","length","splice","canvas","document","getElementById","infoPanel","resize","displayWidth","clientWidth","displayHeight","clientHeight","splitTex","cols","rows","regions","cellWidth","cellHeight","x","y","TextureRegion","getContext","createBatch","mainCharacterTex","mainCharacterRegions","mainCharacterAnimation","createAnimation","pipe","sign","cam","createOrthoCamera","game","deco","inputHandler","InputHandler","BASE_HEIGHT","BASE_WIDTH","baseX","obstacles","setInterval","innerHTML","clearColor","PIPE_HEIGHT","PIPE_WIDTH","BIRD_WIDTH","birdX","birdY","BIRD_HEIGHT","MAX_SPEED","DECELERATION","UP_ANGLE","PI","SPEED_X","GAP","speedY","reset","gameOver","jump","baseParallax","addEventListener","stateTime","clear","COLOR_BUFFER_BIT","min","pipeX","obstacle","setProjection","combined","begin","setColor","getKeyFrame","PlayMode","LOOP","end","init"],"mappings":"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","file":"static/js/main.67e5541c.chunk.js","sourcesContent":["import { EventEmitter } from \"fbemitter\";\n\nconst createLoop = (STEP = 15) => {\n  const eventEmitter = new EventEmitter();\n\n  let running = true;\n  let lastUpdate = Date.now();\n  let elapsed = 0;\n\n  let accumulate = 0;\n\n  const loop = () => {\n    elapsed = Date.now() - lastUpdate;\n    lastUpdate = Date.now();\n\n    accumulate += elapsed;\n    while (accumulate >= STEP) {\n      accumulate -= STEP;\n      eventEmitter.emit(\"fixedTick\", STEP / 1000);\n    }\n\n    eventEmitter.emit(\"tick\", elapsed / 1000);\n    running && requestAnimationFrame(loop);\n  };\n  loop();\n\n  return {\n    onTick(handler) {\n      eventEmitter.addListener(\"tick\", handler);\n    },\n    onFixedTick(handler) {\n      eventEmitter.addListener(\"fixedTick\", handler);\n    },\n    getDelta() {\n      return elapsed / 1000;\n    },\n    getFps() {\n      return Math.round(1000 / elapsed);\n    },\n    stop() {\n      running = false;\n    }\n  };\n};\n\nexport default createLoop;\n","import loadTexture from 'gdxjs/lib/loadTexture';\n\nconst createParallax = (tex, width, height, startX, startY, speedX) => {\n  const texWidth = tex.width;\n  const texHeight = tex.height;\n\n  const regionWidth = (height / texHeight) * texWidth;\n  const regionHeight = height;\n\n  let animateX = 0;\n\n  return {\n    update(delta) {\n      animateX += speedX * delta;\n      if (animateX <= -regionWidth) {\n        animateX = 0;\n      }\n    },\n    draw(batch) {\n      let offsetX = animateX;\n      while (offsetX < width) {\n        batch.draw(tex, startX + offsetX, startY, regionWidth, regionHeight);\n        offsetX += regionWidth;\n      }\n    }\n  };\n};\n\nexport const loadParallax = async (gl, url, width, height, startX, startY, speedX) => {\n  const tex = await loadTexture(gl, url);\n  return createParallax(tex, width, height, startX, startY, speedX);\n};\n\nexport const createParallaxGroup = () => {\n  const parallaxes = [];\n\n  return {\n    add: parallax => parallaxes.push(parallax),\n    addAll: (...ps) => {\n      for (let p of ps) {\n        parallaxes.push(p);\n      }\n    },\n    update(delta) {\n      for (let parallax of parallaxes) {\n        parallax.update(delta);\n      }\n    },\n    draw(batch) {\n      for (let parallax of parallaxes) {\n        parallax.draw(batch);\n      }\n    }\n  };\n};\n\nexport default createParallax;\n","import { createParallaxGroup, loadParallax } from './lib/createParallax';\n\nconst createParallaxes = async (gl, worldWidth, worldHeight) => {\n  const parallaxGroup = createParallaxGroup();\n\n  const baseHeight = 100;\n  const treeHeight = 70;\n  const cloudHeight = 150;\n  const skyHeight = worldHeight - baseHeight - 50;\n  const houseHeight = 120;\n  const wireHeight = 135;\n  const bikeHeight = 50;\n\n  const treeParallax = await loadParallax(\n    gl,\n    './tree.png',\n    worldWidth,\n    treeHeight,\n    0,\n    worldHeight - baseHeight - treeHeight,\n    -50\n  );\n  const cloudParallax = await loadParallax(\n    gl,\n    './cloud.png',\n    worldWidth,\n    cloudHeight,\n    0,\n    worldHeight - baseHeight - cloudHeight,\n    -20\n  );\n  const skyParallax = await loadParallax(gl, './sky.jpg', worldWidth, skyHeight, 0, 0, -5);\n  const houseParallax = await loadParallax(\n    gl,\n    './house.png',\n    worldWidth,\n    houseHeight,\n    0,\n    worldHeight - baseHeight - houseHeight,\n    -30\n  );\n  const wireParallax = await loadParallax(\n    gl,\n    './wire.png',\n    worldWidth,\n    wireHeight,\n    0,\n    worldHeight - baseHeight - wireHeight,\n    -50\n  );\n  const bikeParallax = await loadParallax(\n    gl,\n    './bike.png',\n    worldWidth,\n    bikeHeight,\n    0,\n    worldHeight - baseHeight - bikeHeight,\n    -200\n  );\n  const bike2Parallax = await loadParallax(\n    gl,\n    './bike2.png',\n    worldWidth,\n    bikeHeight,\n    0,\n    worldHeight - baseHeight - bikeHeight,\n    -300\n  );\n\n  parallaxGroup.addAll(\n    skyParallax,\n    cloudParallax,\n    houseParallax,\n    wireParallax,\n    treeParallax,\n    bikeParallax,\n    bike2Parallax\n  );\n\n  return parallaxGroup;\n};\n\nexport default createParallaxes;\n","import loadTexture from 'gdxjs/lib/loadTexture';\n\nconst createDeco = async (gl, worldWidth, worldHeight) => {\n  const beeTextures = [await loadTexture(gl, './bee01.png'), await loadTexture(gl, './bee02.png')];\n  const HEIGHTS = [40, 40];\n  const WIDTHS = [120, 50];\n\n  const xs = [];\n  const ys = [];\n  const ss = [];\n  const ts = [];\n\n  return {\n    update(delta) {\n      if (Math.random() < 0.03) {\n        xs.push(worldWidth);\n        ys.push(Math.random() * (worldHeight / 2) + worldHeight / 8);\n        ss.push(Math.random() * 200 + 200);\n        const type = Math.random() > 0.5 ? 1 : 0;\n        ts.push(type);\n      }\n      for (let i = 0; i < xs.length; i++) {\n        xs[i] = xs[i] - ss[i] * delta;\n      }\n      for (let i = xs.length - 1; i >= 0; i--) {\n        if (xs[i] < -WIDTHS[ts[i]]) {\n          xs.splice(i, 1);\n          ys.splice(i, 1);\n          ss.splice(i, 1);\n          ts.splice(i, 1);\n        }\n      }\n    },\n    draw(batch) {\n      for (let i = 0; i < xs.length; i++) {\n        batch.draw(beeTextures[ts[i]], xs[i], ys[i], WIDTHS[ts[i]], HEIGHTS[ts[i]]);\n      }\n    }\n  };\n};\n\nexport default createDeco;\n","import './index.css';\n\nimport createLoop from './lib/createLoop';\nimport createBatch from 'gdxjs/lib/createBatch';\nimport createOrthoCamera from 'gdxjs/lib/orthoCamera';\nimport InputHandler from 'gdxjs/lib/InputHandler';\nimport TextureRegion from 'gdxjs/lib/TextureRegion';\nimport loadTexture from 'gdxjs/lib/loadTexture';\nimport createAnimation, { PlayMode } from 'gdxjs/lib/createAnimation';\nimport { loadParallax } from './lib/createParallax';\n\nimport createParallaxes from './createParallaxes';\nimport createDeco from './createDeco';\n\nconst canvas = document.getElementById('mainCanvas');\nconst infoPanel = document.getElementById('info');\n\nconst resize = canvas => {\n  const devicePixelRatio = 1;\n\n  const displayWidth = canvas.clientWidth * devicePixelRatio;\n  const displayHeight = canvas.clientHeight * devicePixelRatio;\n\n  if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n  return [displayWidth, displayHeight];\n};\n\nconst splitTex = (tex, cols, rows) => {\n  const regions = [];\n  const cellWidth = tex.width / cols;\n  const cellHeight = tex.height / rows;\n  for (let x = 0; x < cols; x++) {\n    for (let y = 0; y < rows; y++) {\n      regions.push(new TextureRegion(tex, cellWidth * x, cellHeight * y, cellWidth, cellHeight));\n    }\n  }\n  return regions;\n};\n\nconst init = async () => {\n  const [width, height] = resize(canvas);\n\n  const gl = canvas.getContext('webgl');\n  const batch = createBatch(gl);\n\n  const mainCharacterTex = await loadTexture(gl, './main.png');\n  const mainCharacterRegions = splitTex(mainCharacterTex, 3, 1);\n  const mainCharacterAnimation = createAnimation(0.2, mainCharacterRegions);\n\n  const pipe = await loadTexture(gl, './pipe.png');\n  const sign = await loadTexture(gl, './sign.png');\n\n  const worldWidth = 300;\n  const worldHeight = (300 * height) / width;\n  const cam = createOrthoCamera(worldWidth, worldHeight, width, height);\n\n  const game = createLoop();\n\n  const parallaxes = await createParallaxes(gl, worldWidth, worldHeight);\n  const deco = await createDeco(gl, worldWidth, worldHeight);\n\n  const inputHandler = new InputHandler(canvas);\n\n  const BASE_HEIGHT = 100;\n  const BASE_WIDTH = worldWidth;\n\n  let baseX = worldWidth;\n  let obstacles = [\n    Math.random() * (worldHeight - 3 * 100) + 100,\n    Math.random() * (worldHeight - 3 * 100) + 100\n  ];\n\n  setInterval(() => {\n    infoPanel.innerHTML = `FPS: ${game.getFps()}`;\n  }, 1000);\n\n  gl.clearColor(0, 0, 0, 1);\n\n  const BIRD_WIDTH = 36;\n  const BIRD_HEIGHT = 24;\n\n  const PIPE_WIDTH = 2 * BIRD_WIDTH;\n  const PIPE_HEIGHT = (PIPE_WIDTH * 3000) / 376;\n\n  let birdX = 30;\n  let birdY = worldHeight / 3 - BIRD_HEIGHT / 2;\n\n  const MAX_SPEED = 600;\n  const DECELERATION = 1800; // per second\n  const UP_ANGLE = -Math.PI / 6;\n  const SPEED_X = 210;\n\n  const GAP = 5 * BIRD_HEIGHT;\n\n  let speedY = -MAX_SPEED;\n\n  const reset = () => {\n    baseX = worldWidth;\n    obstacles[0] = Math.random() * (worldHeight - 3 * 100) + 100;\n    obstacles[1] = Math.random() * (worldHeight - 3 * 100) + 100;\n    birdY = worldHeight / 3 - BIRD_HEIGHT / 2;\n    gameOver = false;\n    speedY = -MAX_SPEED;\n  };\n\n  const jump = () => {\n    if (!gameOver) {\n      speedY = -MAX_SPEED;\n    } else {\n      reset();\n    }\n  };\n\n  const baseParallax = await loadParallax(\n    gl,\n    './base.jpg',\n    worldWidth,\n    BASE_HEIGHT,\n    0,\n    worldHeight - BASE_HEIGHT,\n    -210\n  );\n\n  inputHandler.addEventListener('touchStart', jump);\n  document.addEventListener('keydown', jump);\n\n  let gameOver = false;\n\n  let stateTime = 0;\n  game.onTick(delta => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    if (!gameOver) {\n      stateTime += delta;\n      parallaxes.update(delta);\n      baseParallax.update(delta);\n      deco.update(delta);\n      speedY += DECELERATION * delta;\n      speedY = Math.min(speedY, MAX_SPEED);\n      birdY += speedY * delta;\n      baseX -= SPEED_X * delta;\n\n      if (baseX <= -worldWidth) {\n        baseX = 0;\n        obstacles[0] = obstacles[1];\n        obstacles[1] = Math.random() * (worldHeight - 3 * BASE_HEIGHT) + BASE_HEIGHT;\n      }\n\n      const pipeX = baseX + BASE_WIDTH * 0.75;\n      if (birdY >= worldHeight - BASE_HEIGHT) {\n        gameOver = true;\n      } else if (birdX <= pipeX + PIPE_WIDTH / 2 && birdX >= pipeX - PIPE_WIDTH / 2) {\n        const obstacle = obstacles[0];\n        gameOver = birdY > obstacle + GAP / 2 || birdY < obstacle - GAP / 2;\n      }\n    }\n\n    batch.setProjection(cam.combined);\n    batch.begin();\n\n    parallaxes.draw(batch);\n    deco.draw(batch);\n    batch.setColor(1, 1, 1, 1);\n\n    for (let i = 0; i < obstacles.length; i++) {\n      batch.draw(\n        pipe,\n        baseX + BASE_WIDTH * 0.75 + BASE_WIDTH * i - PIPE_WIDTH / 2,\n        obstacles[i] + GAP / 2,\n        PIPE_WIDTH,\n        PIPE_HEIGHT\n      );\n      batch.draw(\n        pipe,\n        baseX + BASE_WIDTH * 0.75 + BASE_WIDTH * i - PIPE_WIDTH / 2,\n        obstacles[i] - GAP / 2 - PIPE_HEIGHT,\n        PIPE_WIDTH,\n        PIPE_HEIGHT,\n        PIPE_WIDTH / 2,\n        PIPE_HEIGHT / 2,\n        Math.PI\n      );\n      batch.draw(\n        sign,\n        baseX + BASE_WIDTH * 0.75 + BASE_WIDTH * i - PIPE_WIDTH / 6,\n        obstacles[i] + GAP / 2 + PIPE_WIDTH / 2,\n        PIPE_WIDTH / 3,\n        (PIPE_WIDTH / 3 / 128) * 112\n      );\n    }\n\n    baseParallax.draw(batch);\n\n    mainCharacterAnimation\n      .getKeyFrame(stateTime, PlayMode.LOOP)\n      .draw(\n        batch,\n        birdX,\n        birdY,\n        BIRD_WIDTH,\n        BIRD_HEIGHT,\n        BIRD_WIDTH / 2,\n        BIRD_HEIGHT / 2,\n        speedY < 0 ? UP_ANGLE : ((Math.PI / 2) * speedY) / MAX_SPEED\n      );\n    batch.end();\n  });\n};\n\ninit();\n"],"sourceRoot":""}